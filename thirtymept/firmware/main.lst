   1               		.file	"main.c"
   2               	__SP_L__ = 0x3d
   3               	__SREG__ = 0x3f
   4               	__tmp_reg__ = 0
   5               	__zero_reg__ = 1
   6               		.text
   7               	.Ltext0:
   8               		.cfi_sections	.debug_frame
   9               	.global	spi_init
  11               	spi_init:
  12               	.LFB0:
  13               		.file 1 "main.c"
   1:main.c        **** #include <avr/io.h>
   2:main.c        **** #include <avr/interrupt.h>
   3:main.c        **** #include <avr/sleep.h>
   4:main.c        **** 
   5:main.c        **** // 6 second "dits" --> with that my callsign is a 5 minute, 54 second transmission
   6:main.c        **** #define CWT0OVFS 2929	// number of timer0 overflows per dit --> T0OVS = (ditlength/s * 1MHz/2048)
   7:main.c        **** 
   8:main.c        **** #define MORSEBYTES 8
   9:main.c        **** 
  10:main.c        **** typedef enum{
  11:main.c        **** 	TX_FREQ_LO,
  12:main.c        **** 	TX_FREQ_HI
  13:main.c        **** } tTxFreq;
  14:main.c        **** 
  15:main.c        **** typedef enum{
  16:main.c        **** 	MEPT_TX_START,
  17:main.c        **** 	MEPT_TX_PROGRESS,
  18:main.c        **** 	MEPT_TX_DELAY
  19:main.c        **** } tMeptState;
  20:main.c        **** 
  21:main.c        **** // timer0 overflow counter
  22:main.c        **** volatile uint16_t t0ovfcnt;
  23:main.c        **** 
  24:main.c        **** // counters for keying functions
  25:main.c        **** volatile uint8_t bitcnt;
  26:main.c        **** volatile uint8_t bytecnt;
  27:main.c        **** volatile uint8_t unitcnt;
  28:main.c        **** 
  29:main.c        **** volatile tTxFreq nextfreq;
  30:main.c        **** volatile uint8_t txcomplete;
  31:main.c        **** 
  32:main.c        **** /* AD9850 frequency tuning words
  33:main.c        ****  * two frequencies are defined for CCW (FSK-CW)
  34:main.c        ****  * Note: to keep this firmware simple, these config
  35:main.c        ****  * words already are in the correct bit order (LSB first)
  36:main.c        ****  * use ad9850.py to calculate these words */
  37:main.c        **** const uint8_t ad9850flo[5] = {0xc3, 0xe2, 0x23, 0x28, 0x0};
  38:main.c        **** const uint8_t ad9850fhi[5] = {0x76, 0x12, 0x23, 0x28, 0x0};
  39:main.c        **** 
  40:main.c        **** // 1 unit = 1 bit
  41:main.c        **** // use morsepack.py to generate these bytes
  42:main.c        **** const uint8_t call[8] = {
  43:main.c        **** 	0x1d,0x45,0xd4,0x5d,
  44:main.c        **** 	0xdd,0xc7,0x5d,0xc4
  45:main.c        **** };
  46:main.c        **** 
  47:main.c        **** void spi_init(void)
  48:main.c        **** {
  14               		.loc 1 48 0
  15               		.cfi_startproc
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
  49:main.c        **** 	DDRA |= (1<<PA0);	// AD9850 FQUD
  20               		.loc 1 49 0
  21 0000 D09A      		sbi 0x1a,0
  50:main.c        **** 	DDRB |= (1<<PB7) | (1<<PB6);
  22               		.loc 1 50 0
  23 0002 87B3      		in r24,0x17
  24 0004 806C      		ori r24,lo8(-64)
  25 0006 87BB      		out 0x17,r24
  51:main.c        **** 	USICR |= (1<<USIWM0) | (1<<USICS1) | (1<<USICLK);
  26               		.loc 1 51 0
  27 0008 8DB1      		in r24,0xd
  28 000a 8A61      		ori r24,lo8(26)
  29 000c 8DB9      		out 0xd,r24
  30 000e 0895      		ret
  31               		.cfi_endproc
  32               	.LFE0:
  34               	.global	spi_transfer
  36               	spi_transfer:
  37               	.LFB1:
  52:main.c        **** }
  53:main.c        **** 
  54:main.c        **** uint8_t spi_transfer(uint8_t data)
  55:main.c        **** {
  38               		.loc 1 55 0
  39               		.cfi_startproc
  40               	.LVL0:
  41               	/* prologue: function */
  42               	/* frame size = 0 */
  43               	/* stack size = 0 */
  44               	.L__stack_usage = 0
  56:main.c        **** 	USIDR = data;
  45               		.loc 1 56 0
  46 0010 8FB9      		out 0xf,r24
  57:main.c        **** 	USISR |= (1<<USIOIF);
  47               		.loc 1 57 0
  48 0012 769A      		sbi 0xe,6
  58:main.c        **** 	USICR |= (1<<USIWM0) | (1<<USICS1) | (1<<USICLK) | (1<<USITC);
  49               		.loc 1 58 0
  50 0014 8DB1      		in r24,0xd
  51               	.LVL1:
  52 0016 8B61      		ori r24,lo8(27)
  53 0018 8DB9      		out 0xd,r24
  54               	.LVL2:
  55               	.L3:
  59:main.c        **** 	while(!(USISR & (1<<USIOIF))) USICR |= (1<<USITC);
  56               		.loc 1 59 0 discriminator 1
  57 001a 7699      		sbic 0xe,6
  58 001c 00C0      		rjmp .L6
  59               		.loc 1 59 0 is_stmt 0 discriminator 2
  60 001e 689A      		sbi 0xd,0
  61 0020 00C0      		rjmp .L3
  62               	.L6:
  60:main.c        **** 	return USIDR;
  63               		.loc 1 60 0 is_stmt 1
  64 0022 8FB1      		in r24,0xf
  61:main.c        **** }
  65               		.loc 1 61 0
  66 0024 0895      		ret
  67               		.cfi_endproc
  68               	.LFE1:
  70               	.global	ad9850_setfreq
  72               	ad9850_setfreq:
  73               	.LFB2:
  62:main.c        **** 
  63:main.c        **** void ad9850_setfreq(const uint8_t* conf)
  64:main.c        **** {
  74               		.loc 1 64 0
  75               		.cfi_startproc
  76               	.LVL3:
  77 0026 1F93      		push r17
  78               	.LCFI0:
  79               		.cfi_def_cfa_offset 3
  80               		.cfi_offset 17, -2
  81 0028 CF93      		push r28
  82               	.LCFI1:
  83               		.cfi_def_cfa_offset 4
  84               		.cfi_offset 28, -3
  85 002a DF93      		push r29
  86               	.LCFI2:
  87               		.cfi_def_cfa_offset 5
  88               		.cfi_offset 29, -4
  89               	/* prologue: function */
  90               	/* frame size = 0 */
  91               	/* stack size = 3 */
  92               	.L__stack_usage = 3
  93 002c EC01      		movw r28,r24
  94               	.LVL4:
  95               		.loc 1 64 0
  96 002e 15E0      		ldi r17,lo8(5)
  97               	.LVL5:
  98               	.L9:
  99               	.LBB2:
  65:main.c        **** 	for(uint8_t i = 0; i < 5; i++) spi_transfer(conf[i]);
 100               		.loc 1 65 0 discriminator 2
 101 0030 8991      		ld r24,Y+
 102               	.LVL6:
 103 0032 00D0      		rcall spi_transfer
 104               	.LVL7:
 105 0034 1150      		subi r17,lo8(-(-1))
 106 0036 01F4      		brne .L9
 107               	.LBE2:
  66:main.c        **** 	PORTA |= (1<<PA0);
 108               		.loc 1 66 0
 109 0038 D89A      		sbi 0x1b,0
  67:main.c        **** 	PORTA &= ~(1<<PA0);
 110               		.loc 1 67 0
 111 003a D898      		cbi 0x1b,0
 112               	/* epilogue start */
  68:main.c        **** }
 113               		.loc 1 68 0
 114 003c DF91      		pop r29
 115 003e CF91      		pop r28
 116               	.LVL8:
 117 0040 1F91      		pop r17
 118 0042 0895      		ret
 119               		.cfi_endproc
 120               	.LFE2:
 122               	.global	key_init
 124               	key_init:
 125               	.LFB3:
  69:main.c        **** 
  70:main.c        **** void key_init(void)
  71:main.c        **** {
 126               		.loc 1 71 0
 127               		.cfi_startproc
 128               	/* prologue: function */
 129               	/* frame size = 0 */
 130               	/* stack size = 0 */
 131               	.L__stack_usage = 0
  72:main.c        **** 	DDRD |= (1<<PD0);
 132               		.loc 1 72 0
 133 0044 889A      		sbi 0x11,0
  73:main.c        **** 	PORTD &= ~(1<<PD0);
 134               		.loc 1 73 0
 135 0046 9098      		cbi 0x12,0
 136 0048 0895      		ret
 137               		.cfi_endproc
 138               	.LFE3:
 140               	.global	keyfsk
 142               	keyfsk:
 143               	.LFB4:
  74:main.c        **** }
  75:main.c        **** 
  76:main.c        **** void keyfsk(void)
  77:main.c        **** {
 144               		.loc 1 77 0
 145               		.cfi_startproc
 146               	/* prologue: function */
 147               	/* frame size = 0 */
 148               	/* stack size = 0 */
 149               	.L__stack_usage = 0
  78:main.c        **** 	if(bytecnt < MORSEBYTES)
 150               		.loc 1 78 0
 151 004a 8091 0000 		lds r24,bytecnt
 152 004e 8830      		cpi r24,lo8(8)
 153 0050 00F4      		brsh .L12
  79:main.c        **** 	{
  80:main.c        **** 		if(bitcnt < 7)
 154               		.loc 1 80 0
 155 0052 8091 0000 		lds r24,bitcnt
  81:main.c        **** 		{
  82:main.c        **** 			if((call[bytecnt]>>(7-bitcnt)) & 1) nextfreq = TX_FREQ_HI;
 156               		.loc 1 82 0
 157 0056 E091 0000 		lds r30,bytecnt
  80:main.c        **** 		if(bitcnt < 7)
 158               		.loc 1 80 0
 159 005a 8730      		cpi r24,lo8(7)
 160 005c 00F4      		brsh .L13
 161               		.loc 1 82 0
 162 005e 4091 0000 		lds r20,bitcnt
 163 0062 F0E0      		ldi r31,0
 164 0064 E050      		subi r30,lo8(-(call))
 165 0066 F040      		sbci r31,hi8(-(call))
 166 0068 8081      		ld r24,Z
 167 006a 90E0      		ldi r25,0
 168 006c 27E0      		ldi r18,lo8(7)
 169 006e 30E0      		ldi r19,0
 170 0070 241B      		sub r18,r20
 171 0072 3109      		sbc r19,__zero_reg__
 172 0074 00C0      		rjmp 2f
 173               		1:
 174 0076 9595      		asr r25
 175 0078 8795      		ror r24
 176               		2:
 177 007a 2A95      		dec r18
 178 007c 02F4      		brpl 1b
 179 007e 80FF      		sbrs r24,0
 180 0080 00C0      		rjmp .L14
 181               		.loc 1 82 0 is_stmt 0 discriminator 1
 182 0082 81E0      		ldi r24,lo8(1)
 183 0084 8093 0000 		sts nextfreq,r24
 184 0088 00C0      		rjmp .L15
 185               	.L14:
  83:main.c        **** 			else nextfreq = TX_FREQ_LO;
 186               		.loc 1 83 0 is_stmt 1
 187 008a 1092 0000 		sts nextfreq,__zero_reg__
 188               	.L15:
  84:main.c        **** 			bitcnt++;
 189               		.loc 1 84 0 discriminator 1
 190 008e 8091 0000 		lds r24,bitcnt
 191 0092 8F5F      		subi r24,lo8(-(1))
 192 0094 8093 0000 		sts bitcnt,r24
 193 0098 0895      		ret
 194               	.L13:
  85:main.c        **** 		} else {
  86:main.c        **** 			if(call[bytecnt] & 1) nextfreq = TX_FREQ_HI;
 195               		.loc 1 86 0
 196 009a F0E0      		ldi r31,0
 197 009c E050      		subi r30,lo8(-(call))
 198 009e F040      		sbci r31,hi8(-(call))
 199 00a0 8081      		ld r24,Z
 200 00a2 80FF      		sbrs r24,0
 201 00a4 00C0      		rjmp .L17
 202               		.loc 1 86 0 is_stmt 0 discriminator 1
 203 00a6 81E0      		ldi r24,lo8(1)
 204 00a8 8093 0000 		sts nextfreq,r24
 205 00ac 00C0      		rjmp .L18
 206               	.L17:
  87:main.c        **** 			else nextfreq = TX_FREQ_LO;
 207               		.loc 1 87 0 is_stmt 1
 208 00ae 1092 0000 		sts nextfreq,__zero_reg__
 209               	.L18:
  88:main.c        **** 			bitcnt = 0;
 210               		.loc 1 88 0
 211 00b2 1092 0000 		sts bitcnt,__zero_reg__
  89:main.c        **** 			bytecnt++;
 212               		.loc 1 89 0
 213 00b6 8091 0000 		lds r24,bytecnt
 214 00ba 8F5F      		subi r24,lo8(-(1))
 215 00bc 8093 0000 		sts bytecnt,r24
 216 00c0 0895      		ret
 217               	.L12:
  90:main.c        **** 		}
  91:main.c        **** 	} else {
  92:main.c        **** 		txcomplete = 1;
 218               		.loc 1 92 0
 219 00c2 81E0      		ldi r24,lo8(1)
 220 00c4 8093 0000 		sts txcomplete,r24
 221 00c8 0895      		ret
 222               		.cfi_endproc
 223               	.LFE4:
 225               	.global	timer0_start
 227               	timer0_start:
 228               	.LFB5:
  93:main.c        **** 	}
  94:main.c        **** }
  95:main.c        **** 
  96:main.c        **** void timer0_start(void)
  97:main.c        **** {
 229               		.loc 1 97 0
 230               		.cfi_startproc
 231               	/* prologue: function */
 232               	/* frame size = 0 */
 233               	/* stack size = 0 */
 234               	.L__stack_usage = 0
  98:main.c        **** 	t0ovfcnt = 0;
 235               		.loc 1 98 0
 236 00ca 1092 0000 		sts t0ovfcnt+1,__zero_reg__
 237 00ce 1092 0000 		sts t0ovfcnt,__zero_reg__
  99:main.c        **** 	TCNT0 = 0;
 238               		.loc 1 99 0
 239 00d2 12BE      		out 0x32,__zero_reg__
 100:main.c        **** 	// enable timer0 interrupt
 101:main.c        **** 	TIMSK |= (1<<TOIE0);
 240               		.loc 1 101 0
 241 00d4 89B7      		in r24,0x39
 242 00d6 8260      		ori r24,lo8(2)
 243 00d8 89BF      		out 0x39,r24
 102:main.c        **** 	// start timer0, prescaler 8
 103:main.c        **** 	TCCR0B |= (1<<CS01);
 244               		.loc 1 103 0
 245 00da 83B7      		in r24,0x33
 246 00dc 8260      		ori r24,lo8(2)
 247 00de 83BF      		out 0x33,r24
 248 00e0 0895      		ret
 249               		.cfi_endproc
 250               	.LFE5:
 252               	.global	timer0_stop
 254               	timer0_stop:
 255               	.LFB6:
 104:main.c        **** }
 105:main.c        **** 
 106:main.c        **** void timer0_stop(void)
 107:main.c        **** {
 256               		.loc 1 107 0
 257               		.cfi_startproc
 258               	/* prologue: function */
 259               	/* frame size = 0 */
 260               	/* stack size = 0 */
 261               	.L__stack_usage = 0
 108:main.c        **** 	TCCR0B &= ~(1<<CS01);
 262               		.loc 1 108 0
 263 00e2 83B7      		in r24,0x33
 264 00e4 8D7F      		andi r24,lo8(-3)
 265 00e6 83BF      		out 0x33,r24
 109:main.c        **** 	TIMSK &= ~(1<<TOIE0);
 266               		.loc 1 109 0
 267 00e8 89B7      		in r24,0x39
 268 00ea 8D7F      		andi r24,lo8(-3)
 269 00ec 89BF      		out 0x39,r24
 270 00ee 0895      		ret
 271               		.cfi_endproc
 272               	.LFE6:
 274               		.section	.text.startup,"ax",@progbits
 275               	.global	main
 277               	main:
 278               	.LFB7:
 110:main.c        **** }
 111:main.c        **** 
 112:main.c        **** int main(void)
 113:main.c        **** {
 279               		.loc 1 113 0
 280               		.cfi_startproc
 281               	/* prologue: function */
 282               	/* frame size = 0 */
 283               	/* stack size = 0 */
 284               	.L__stack_usage = 0
 114:main.c        **** 	tMeptState currstate,nextstate;
 115:main.c        **** 	tTxFreq currfreq;
 116:main.c        **** 
 117:main.c        **** 	spi_init();
 285               		.loc 1 117 0
 286 0000 00D0      		rcall spi_init
 287               	.LVL9:
 118:main.c        **** 	key_init();
 288               		.loc 1 118 0
 289 0002 00D0      		rcall key_init
 290               	.LVL10:
 119:main.c        **** 
 120:main.c        **** 	currstate = MEPT_TX_START;
 121:main.c        **** 	nextstate = MEPT_TX_START;
 122:main.c        **** 
 123:main.c        **** 	currfreq = TX_FREQ_HI;
 124:main.c        **** 	nextfreq = TX_FREQ_LO;
 291               		.loc 1 124 0
 292 0004 1092 0000 		sts nextfreq,__zero_reg__
 125:main.c        **** 
 126:main.c        **** 	ad9850_setfreq(ad9850flo);
 293               		.loc 1 126 0
 294 0008 80E0      		ldi r24,lo8(ad9850flo)
 295 000a 90E0      		ldi r25,hi8(ad9850flo)
 296 000c 00D0      		rcall ad9850_setfreq
 297               	.LVL11:
 127:main.c        **** 
 128:main.c        **** 	sei();
 298               		.loc 1 128 0
 299               	/* #APP */
 300               	 ;  128 "main.c" 1
 301 000e 7894      		sei
 302               	 ;  0 "" 2
 303               	.LVL12:
 304               	/* #NOAPP */
 305               	.L25:
 129:main.c        **** 
 130:main.c        **** 	while(1)
 131:main.c        **** 	{
 132:main.c        **** 		switch(currstate)
 133:main.c        **** 		{
 134:main.c        **** 			case MEPT_TX_START:
 135:main.c        **** 				// reset all status variables
 136:main.c        **** 				txcomplete = 0;
 306               		.loc 1 136 0
 307 0010 1092 0000 		sts txcomplete,__zero_reg__
 137:main.c        **** 				unitcnt = 0;
 308               		.loc 1 137 0
 309 0014 1092 0000 		sts unitcnt,__zero_reg__
 138:main.c        **** 				bitcnt = 0;
 310               		.loc 1 138 0
 311 0018 1092 0000 		sts bitcnt,__zero_reg__
 139:main.c        **** 				bytecnt = 0;
 312               		.loc 1 139 0
 313 001c 1092 0000 		sts bytecnt,__zero_reg__
 314               	.LVL13:
 140:main.c        **** 
 141:main.c        **** 				currfreq = TX_FREQ_HI;
 142:main.c        **** 				nextfreq = TX_FREQ_LO;
 315               		.loc 1 142 0
 316 0020 1092 0000 		sts nextfreq,__zero_reg__
 143:main.c        **** 
 144:main.c        **** 				timer0_stop();
 317               		.loc 1 144 0
 318 0024 00D0      		rcall timer0_stop
 319               	.LVL14:
 145:main.c        **** 				// key up transmitter
 146:main.c        **** 				PORTD |= (1<<PD0);
 320               		.loc 1 146 0
 321 0026 909A      		sbi 0x12,0
 147:main.c        **** 				timer0_start();
 322               		.loc 1 147 0
 323 0028 00D0      		rcall timer0_start
 324               	.LVL15:
 141:main.c        **** 				currfreq = TX_FREQ_HI;
 325               		.loc 1 141 0
 326 002a 81E0      		ldi r24,lo8(1)
 327               	.LVL16:
 328               	.L24:
 148:main.c        **** 				nextstate = MEPT_TX_PROGRESS;
 149:main.c        **** 				break;
 150:main.c        **** 
 151:main.c        **** 			case MEPT_TX_PROGRESS:
 152:main.c        **** 				if(currfreq != nextfreq)
 329               		.loc 1 152 0
 330 002c 9091 0000 		lds r25,nextfreq
 331 0030 8917      		cp r24,r25
 332 0032 01F0      		breq .L29
 153:main.c        **** 				{
 154:main.c        **** 					if(nextfreq == TX_FREQ_LO) ad9850_setfreq(ad9850flo);
 333               		.loc 1 154 0
 334 0034 8091 0000 		lds r24,nextfreq
 335 0038 8111      		cpse r24,__zero_reg__
 336 003a 00C0      		rjmp .L30
 337               		.loc 1 154 0 is_stmt 0 discriminator 1
 338 003c 80E0      		ldi r24,lo8(ad9850flo)
 339 003e 90E0      		ldi r25,hi8(ad9850flo)
 340 0040 00C0      		rjmp .L36
 341               	.L30:
 155:main.c        **** 					else if(nextfreq == TX_FREQ_HI) ad9850_setfreq(ad9850fhi);
 342               		.loc 1 155 0 is_stmt 1
 343 0042 8091 0000 		lds r24,nextfreq
 344 0046 8130      		cpi r24,lo8(1)
 345 0048 01F4      		brne .L31
 346               		.loc 1 155 0 is_stmt 0 discriminator 1
 347 004a 80E0      		ldi r24,lo8(ad9850fhi)
 348 004c 90E0      		ldi r25,hi8(ad9850fhi)
 349               	.L36:
 350 004e 00D0      		rcall ad9850_setfreq
 351               	.LVL17:
 352               	.L31:
 156:main.c        **** 					currfreq = nextfreq;
 353               		.loc 1 156 0 is_stmt 1
 354 0050 8091 0000 		lds r24,nextfreq
 355               	.LVL18:
 356               	.L29:
 157:main.c        **** 				}
 158:main.c        **** 				if(txcomplete){
 357               		.loc 1 158 0
 358 0054 9091 0000 		lds r25,txcomplete
 359 0058 9923      		tst r25
 360 005a 01F0      		breq .L24
 159:main.c        **** 					// key down transmitter
 160:main.c        **** 					PORTD &= ~(1<<PD0);
 361               		.loc 1 160 0
 362 005c 9098      		cbi 0x12,0
 363               	.LVL19:
 364               	.L26:
 161:main.c        **** 					nextstate = MEPT_TX_DELAY;
 162:main.c        **** 				} else nextstate = MEPT_TX_PROGRESS;
 163:main.c        **** 				break;
 164:main.c        **** 
 165:main.c        **** 			case MEPT_TX_DELAY:
 166:main.c        **** 				if(unitcnt < 100) nextstate = MEPT_TX_DELAY;
 365               		.loc 1 166 0
 366 005e 8091 0000 		lds r24,unitcnt
 367 0062 8436      		cpi r24,lo8(100)
 368 0064 00F4      		brsh .L25
 369 0066 00C0      		rjmp .L26
 370               		.cfi_endproc
 371               	.LFE7:
 373               		.text
 374               	.global	__vector_6
 376               	__vector_6:
 377               	.LFB8:
 167:main.c        **** 				else nextstate = MEPT_TX_START;
 168:main.c        **** 				break;
 169:main.c        **** 		}
 170:main.c        **** 		currstate = nextstate;
 171:main.c        **** 	}
 172:main.c        **** 	return 0;
 173:main.c        **** }
 174:main.c        **** 
 175:main.c        **** ISR(TIMER0_OVF_vect)
 176:main.c        **** {
 378               		.loc 1 176 0
 379               		.cfi_startproc
 380 00f0 1F92      		push r1
 381               	.LCFI3:
 382               		.cfi_def_cfa_offset 3
 383               		.cfi_offset 1, -2
 384 00f2 0F92      		push r0
 385               	.LCFI4:
 386               		.cfi_def_cfa_offset 4
 387               		.cfi_offset 0, -3
 388 00f4 0FB6      		in r0,__SREG__
 389 00f6 0F92      		push r0
 390 00f8 1124      		clr __zero_reg__
 391 00fa 2F93      		push r18
 392               	.LCFI5:
 393               		.cfi_def_cfa_offset 5
 394               		.cfi_offset 18, -4
 395 00fc 3F93      		push r19
 396               	.LCFI6:
 397               		.cfi_def_cfa_offset 6
 398               		.cfi_offset 19, -5
 399 00fe 4F93      		push r20
 400               	.LCFI7:
 401               		.cfi_def_cfa_offset 7
 402               		.cfi_offset 20, -6
 403 0100 5F93      		push r21
 404               	.LCFI8:
 405               		.cfi_def_cfa_offset 8
 406               		.cfi_offset 21, -7
 407 0102 6F93      		push r22
 408               	.LCFI9:
 409               		.cfi_def_cfa_offset 9
 410               		.cfi_offset 22, -8
 411 0104 7F93      		push r23
 412               	.LCFI10:
 413               		.cfi_def_cfa_offset 10
 414               		.cfi_offset 23, -9
 415 0106 8F93      		push r24
 416               	.LCFI11:
 417               		.cfi_def_cfa_offset 11
 418               		.cfi_offset 24, -10
 419 0108 9F93      		push r25
 420               	.LCFI12:
 421               		.cfi_def_cfa_offset 12
 422               		.cfi_offset 25, -11
 423 010a AF93      		push r26
 424               	.LCFI13:
 425               		.cfi_def_cfa_offset 13
 426               		.cfi_offset 26, -12
 427 010c BF93      		push r27
 428               	.LCFI14:
 429               		.cfi_def_cfa_offset 14
 430               		.cfi_offset 27, -13
 431 010e EF93      		push r30
 432               	.LCFI15:
 433               		.cfi_def_cfa_offset 15
 434               		.cfi_offset 30, -14
 435 0110 FF93      		push r31
 436               	.LCFI16:
 437               		.cfi_def_cfa_offset 16
 438               		.cfi_offset 31, -15
 439               	/* prologue: Signal */
 440               	/* frame size = 0 */
 441               	/* stack size = 15 */
 442               	.L__stack_usage = 15
 177:main.c        **** 	if(t0ovfcnt < CWT0OVFS) t0ovfcnt++;
 443               		.loc 1 177 0
 444 0112 8091 0000 		lds r24,t0ovfcnt
 445 0116 9091 0000 		lds r25,t0ovfcnt+1
 446 011a 8137      		cpi r24,113
 447 011c 9B40      		sbci r25,11
 448 011e 00F4      		brsh .L38
 449               		.loc 1 177 0 is_stmt 0 discriminator 1
 450 0120 8091 0000 		lds r24,t0ovfcnt
 451 0124 9091 0000 		lds r25,t0ovfcnt+1
 452 0128 0196      		adiw r24,1
 453 012a 9093 0000 		sts t0ovfcnt+1,r25
 454 012e 8093 0000 		sts t0ovfcnt,r24
 455 0132 00C0      		rjmp .L37
 456               	.L38:
 178:main.c        **** 	else {
 179:main.c        **** 		t0ovfcnt = 0;
 457               		.loc 1 179 0 is_stmt 1
 458 0134 1092 0000 		sts t0ovfcnt+1,__zero_reg__
 459 0138 1092 0000 		sts t0ovfcnt,__zero_reg__
 180:main.c        ****  		unitcnt++;
 460               		.loc 1 180 0
 461 013c 8091 0000 		lds r24,unitcnt
 462 0140 8F5F      		subi r24,lo8(-(1))
 463 0142 8093 0000 		sts unitcnt,r24
 181:main.c        **** 		keyfsk();
 464               		.loc 1 181 0
 465 0146 00D0      		rcall keyfsk
 466               	.LVL20:
 467               	.L37:
 468               	/* epilogue start */
 182:main.c        **** 	}
 183:main.c        **** }
 469               		.loc 1 183 0
 470 0148 FF91      		pop r31
 471 014a EF91      		pop r30
 472 014c BF91      		pop r27
 473 014e AF91      		pop r26
 474 0150 9F91      		pop r25
 475 0152 8F91      		pop r24
 476 0154 7F91      		pop r23
 477 0156 6F91      		pop r22
 478 0158 5F91      		pop r21
 479 015a 4F91      		pop r20
 480 015c 3F91      		pop r19
 481 015e 2F91      		pop r18
 482 0160 0F90      		pop r0
 483 0162 0FBE      		out __SREG__,r0
 484 0164 0F90      		pop r0
 485 0166 1F90      		pop r1
 486 0168 1895      		reti
 487               		.cfi_endproc
 488               	.LFE8:
 490               	.global	call
 491               		.section	.rodata
 494               	call:
 495 0000 1D        		.byte	29
 496 0001 45        		.byte	69
 497 0002 D4        		.byte	-44
 498 0003 5D        		.byte	93
 499 0004 DD        		.byte	-35
 500 0005 C7        		.byte	-57
 501 0006 5D        		.byte	93
 502 0007 C4        		.byte	-60
 503               	.global	ad9850fhi
 506               	ad9850fhi:
 507 0008 76        		.byte	118
 508 0009 12        		.byte	18
 509 000a 23        		.byte	35
 510 000b 28        		.byte	40
 511 000c 00        		.byte	0
 512               	.global	ad9850flo
 515               	ad9850flo:
 516 000d C3        		.byte	-61
 517 000e E2        		.byte	-30
 518 000f 23        		.byte	35
 519 0010 28        		.byte	40
 520 0011 00        		.byte	0
 521               		.comm	txcomplete,1,1
 522               		.comm	nextfreq,1,1
 523               		.comm	unitcnt,1,1
 524               		.comm	bytecnt,1,1
 525               		.comm	bitcnt,1,1
 526               		.comm	t0ovfcnt,2,1
 527               		.text
 528               	.Letext0:
 529               		.file 2 "/usr/lib/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccy8XSX2.s:2      *ABS*:000000000000003d __SP_L__
     /tmp/ccy8XSX2.s:3      *ABS*:000000000000003f __SREG__
     /tmp/ccy8XSX2.s:4      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccy8XSX2.s:5      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccy8XSX2.s:11     .text:0000000000000000 spi_init
     /tmp/ccy8XSX2.s:36     .text:0000000000000010 spi_transfer
     /tmp/ccy8XSX2.s:72     .text:0000000000000026 ad9850_setfreq
     /tmp/ccy8XSX2.s:124    .text:0000000000000044 key_init
     /tmp/ccy8XSX2.s:142    .text:000000000000004a keyfsk
                            *COM*:0000000000000001 bytecnt
                            *COM*:0000000000000001 bitcnt
     /tmp/ccy8XSX2.s:494    .rodata:0000000000000000 call
                            *COM*:0000000000000001 nextfreq
                            *COM*:0000000000000001 txcomplete
     /tmp/ccy8XSX2.s:227    .text:00000000000000ca timer0_start
                            *COM*:0000000000000002 t0ovfcnt
     /tmp/ccy8XSX2.s:254    .text:00000000000000e2 timer0_stop
     /tmp/ccy8XSX2.s:277    .text.startup:0000000000000000 main
     /tmp/ccy8XSX2.s:515    .rodata:000000000000000d ad9850flo
                            *COM*:0000000000000001 unitcnt
     /tmp/ccy8XSX2.s:506    .rodata:0000000000000008 ad9850fhi
     /tmp/ccy8XSX2.s:376    .text:00000000000000f0 __vector_6

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
